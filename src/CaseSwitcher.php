<?php
class CaseSwitcher
{
    /**
     * Path to the directory
     *
     * @var string
     */
    private $directory;

    /**
     * The case to rename files to
     *
     * @var string
     */
    private $case;

    /**
     * Should CaseSwitcher switch filenames recursively?
     *
     * @var bool
     */
    private $recursion;

    /**
     * Error message generated by CaseSwitcher
     *
     * @var string
     */
    private $errMsg;

    /**
     * The state of verboseness of CaseSwitcher
     *
     * @var bool
     */
    private $verboseness;

    /**
     * Iterator to be used in renaming files
     *
     * @var iterator
     */
    private $iterator;

    /**
     * A list of forbidden paths this system cannot touch
     */
    private $restrictedPaths = [
        '/'
    ];


    public function __construct()
    {
        $this->restrictedPaths[] = getenv('HOME');
    }

    /**
     * Rename the the directory contents to the specified case.
     *
     * @return bool
     */
    public function run() : bool
    {
        $this->iterator = $this->createIterator();
        return $this->renameFiles();
    }

    /**
     * Rename contents of a directory either one level deep or recursively
     *
     * @param Iterator $iterator The type of iterator to use
     * @return bool True if the renaming succeeds
     */
    private function renameFiles() : bool
    {
        foreach ($this->iterator as $file) {
            $oldName = $file->getPathName();
            $newName = $this->getNewName($file);
            $renamed = @rename($oldName, $newName);

            if ($this->verboseness && $renamed) {
                $this->reportVerbosity("{$oldName} was renamed to {$newName}");
            }
        }
        return true;
    }


    /**
     * Creates an iterator to be used in renaming the contents of
     * the directory
     *
     * @return void
     * @throws UnexpectedValueException
     */
    private function createIterator()
    {
        switch ($this->recursion) {
            case true:
                return new \RecursiveIteratorIterator(
                    new \RecursiveDirectoryIterator($this->directory),
                    \RecursiveIteratorIterator::CHILD_FIRST
                );
                break;

            case false:
                return new \DirectoryIterator($this->directory);
                break;

            default:
                throw new \UnexpectedValueException('Unknown iterator type supplied');
        }
    }

    /**
     * Reports to output what operation was just performed
     *
     * @param string $msg The report message
     * @return void
     */
    private function reportVerbosity($msg)
    {
        printf("[\e[1;32mOK\e[m] %s" . PHP_EOL, $msg);
    }

    /**
     * Converts filename to the requested case
     *
     * @param string $fileName Name of the file
     * @return string The converted version of the filename
     */
    private function changeCase($fileName) : string
    {
        switch ($this->case) {
            case 'upper':
                return strtoupper($fileName);
                break;
            case 'lower':
                return strtolower($fileName);
                break;
        }
    }


    /**
     * Gets the extension of the file
     *
     * @return string The extension of the file
     */
    private function getExtension($file) : string
    {
        return (empty($file)) ? '' : ".{$file}";
    }


    /**
     * Get error message
     *
     * @return string The cuurrent error message
     */
    public function getErrorMsg() : string
    {
        return $this->errMsg;
    }


    /**
     * Generate the new name of the file being renamed. This will be used by the
     * rename() function.
     *
     * @param SplFileInfo $file. The file to be renamed will be an instance of SplFileInfo
     * @return string. The new name of the file after it has been renamed
     */
    private function getNewName(\SplFileInfo $file) : string
    {
        $directory = $file->getPath();
        $filename = $this->changeCase(pathinfo($file->getFilename(), PATHINFO_FILENAME));
        $fileExtension = $this->getExtension($file->getExtension());
        return "{$directory}" . DIRECTORY_SEPARATOR . "{$filename}{$fileExtension}";
    }

    /**
     * Sets the path to the directory whose contents are to be renamed
     *
     * @param string $directory The path to the directory
     * @return void
     */
    public function setDirectory(string $directory)
    {
        $directory = realpath($directory);
        if (in_array($directory, $this->restrictedPaths)) {
            throw new \Exception('The supplied path is forbidden');
        } elseif (is_null($directory)) {
            throw new \Exception('Expected a directory. None supplied');
        } elseif ($directory && !file_exists($directory)) {
            throw new \Exception('The given directory does not exist');
        } elseif ($directory && file_exists($directory) && !is_dir($directory)) {
            throw new \Exception('The given directory appears not to be a directory');
        } elseif ($directory && !is_writable($directory)) {
            throw new \Exception('The given directory is not writable');
        } elseif (count(scandir($directory)) <= 2) {
            throw new \Exception('Given directory is empty. Nothing here to rename');
        }

        $this->directory = $directory;
        return true;
    }

    /**
     * Sets the case to switch filenames to
     *
     * @param string $case The case. Valid arguments are: 'upper' or 'lower'
     * @return bool True if successful, False if invalid case type is supplied
     * @throws UnexpectedValueException
     */
    public function setCase(string $case)
    {
        if (!in_array($case, ['lower', 'upper'])) {
            throw new \UnexpectedValueException('Unrecognized case type. Use either \'lower\' or \'upper\'');
        }

        $this->case = $case;
        return true;
    }

    /**
     * Sets whether CaseSwitcher should be verbose and report
     * what it is doing to output
     *
     * @param boolean $verboseness True for verboseness, False for no verboseness
     * @return void
     */
    public function setVerboseness(bool $verboseness)
    {
        $this->verboseness = $verboseness;
    }

    /**
     * Instructs CaseSwitcher whether to rename files recursively or not
     * Defaults to False
     *
     * @param bool $recursion True to rename recursively. Defaults to False
     * @return void
     */
    public function setRecursion(bool $recursion)
    {
        $this->recursion = $recursion;
    }
}
